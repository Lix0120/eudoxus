import tactic
import group_theory.quotient_group
import algebra.archimedean

open_locale classical

def df (f : ‚Ñ§ ‚Üí ‚Ñ§) : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§ := Œª p q, f (p + q) - f (p) - f (q)

def almost_homo (f : ‚Ñ§ ‚Üí ‚Ñ§) : Prop := ‚àÉ C, ‚àÄ p q, abs (df f p q) < C 

@[simp] lemma d_equal (f : ‚Ñ§ ‚Üí ‚Ñ§) (p q : ‚Ñ§) : df f p q = f (p + q) - f (p) - f (q) := rfl

def S := {f | almost_homo f}

instance add_group_S : add_group S := {
  add := Œª f g, ‚ü®Œª z, f.1 z + g.1 z, begin
    rcases f with ‚ü®f, C1, hf‚ü©,
    rcases g with ‚ü®g, C2, hg‚ü©,
    use C1 + C2,
    intros p q,
    specialize hf p q,
    specialize hg p q,
    have h1 : df (Œª (z : ‚Ñ§), f z + g z) p q = df f p q + df g p q,
      simp,
      ring,
    rw h1,
    linarith [abs_add (df f p q) (df g p q)],
  end‚ü©,
  add_assoc := begin
    intros f g h,
    simp,
    ring,
  end,
  zero := ‚ü®Œª p, 0, begin
    use 1,
    simp,
  end‚ü©,
  zero_add := begin
    intro f,
    unfold has_add.add,
    simp,
  end,
  add_zero := begin
    intro f,
    unfold has_add.add,
    simp,  
  end,
  neg := Œª f, ‚ü®Œª p, - f.1 p, begin
    rcases f with ‚ü®f, C1, hf‚ü©,
    use C1,
    simp,
    intros p q,
    specialize hf p q,
    simp at hf,
    have h : f p - f (p + q) + f q = - (f (p + q) - f p - f q),
      ring,
    rw [h, abs_neg],
    exact hf,
  end‚ü©,
  add_left_neg := begin
    intro f,
    unfold has_add.add add_semigroup.add has_zero.zero,
    simp,
  end }

instance : add_comm_group S := {
  add_comm := begin
    intros f g,
    unfold has_add.add add_semigroup.add has_add.add add_group.add,
    simp,
    simp_rw [add_comm],
  end,
  ..add_group_S }

def B : add_subgroup S :=
{ carrier := {f : S | ‚àÉ C, ‚àÄ p, abs (f.1 p) < C},
  zero_mem' := begin
    unfold has_zero.zero add_monoid.zero add_group.zero,
    use 1,
    intro p,
    simp,
  end,
  add_mem' := begin
    rintro f g ‚ü®C1, hf‚ü© ‚ü®C2, hg‚ü©,
    use C1 + C2,
    intro p,
    specialize hf p,
    specialize hg p,
    unfold has_add.add add_semigroup.add add_monoid.add add_group.add,
    simp,
    change abs (f.1 p + g.1 p) < C1 + C2,
    linarith [abs_add (f.1 p) (g.1 p)],
  end,
  neg_mem' := begin
    rintro f ‚ü®C, hf‚ü©,
    unfold has_neg.neg add_group.neg,
    use C,
    intro p,
    specialize hf p,
    change abs (-(f.val p)) < C,
    simp,
    exact hf,
  end }

def eudoxus_reals_group := quotient_add_group.quotient B
notation `ùîº` := eudoxus_reals_group

instance add_comm_group_ùîº : add_comm_group ùîº := quotient_add_group.add_comm_group B

lemma lemma1 {f : ‚Ñ§ ‚Üí ‚Ñ§} (hf1 : almost_homo f) (hf2 : ‚àÄ n (hn : 0 < n), ‚àÉ p (hp : 0 < p), n < f p) :
‚àÄ D, 0 < D ‚Üí ‚àÉ M (hM : 0 < M), ‚àÄ m, 0 < m ‚Üí (m + 1) * D < f (m * M) :=
begin
  rcases hf1 with ‚ü®C, hf1‚ü©,
  intros D hD,
  set E := C + D with hE,
  have key : ‚àÉ M (hM : 0 < M), 2 * E < f M,
    have h2E : 0 < 2 * E,
      linarith [hf1 0 0, abs_nonneg (df f 0 0)],
    rcases hf2 (2 * E) h2E with ‚ü®M, hM, H‚ü©,
    use [M, hM],
    exact H,
  rcases key with ‚ü®M, hM, hfM‚ü©,
  use [M, hM],
  intros m hm,
  have hC : 0 ‚â§ C,
    specialize hf1 1 2,
    linarith [abs_nonneg (df f 1 2)],
  have hED : ‚àÄ k, 0 < k ‚Üí (k + 1) * D ‚â§ (k + 1) * E,
    intros k hk,
    rw mul_le_mul_left,
      linarith,
    linarith,
  apply lt_of_le_of_lt (hED m hm),
  induction m,
  { induction m with m h,
      exfalso,
      exact hm,
    have hm0 : m = 0 ‚à® 0 < m,
      exact nat.eq_zero_or_pos m,
    cases hm0,
    { rw hm0,
      simp,
      exact hfM, },
    { have hm0' : int.of_nat m > 0,
        exact int.lt_to_nat.mp hm0,
      specialize h hm0',
      have hdf1 : f ((int.of_nat m.succ) * M) = 
        f (int.of_nat m * M) + f (M) + df f (int.of_nat m * M) (M),
        simp,
        ring,
        rw mul_comm,
      have hdf2 : -E < df f (int.of_nat m * M) M,
        specialize hf1 (int.of_nat m * M) M,
        rw abs_lt at hf1,
        linarith,
      have h1 : (int.of_nat m + 1) * E + 2 * E + (-E) < 
        f (int.of_nat m * M) + f M + df f (int.of_nat m * M) M,
        linarith,
      have h2 : (int.of_nat m.succ + 1) * E = (int.of_nat m + 1) * E + 2 * E + (-E),
        dsimp,
        ring,
      linarith, }, },
  { exfalso,
    exact hm, },
end

theorem QRT : ‚àÄ n m : ‚Ñ§, m > 0 ‚Üí ‚àÉ q r : ‚Ñ§, n = m * q + r ‚àß (0 ‚â§ r ‚àß r < m) :=
begin
  intros n m h,
  use (n / m),
  use (n % m),
  have HH:  n = m * (n / m)  + (n % m), from calc
    n = n % m + m * (n / m) : by rw [int.mod_add_div]
    ... = m * (n / m) + (n % m) : by rw add_comm,
  have HH1: 0 ‚â§ (n % m), from int.mod_nonneg n (ne_of_gt h),
  have HH2: (n % m) < m, from calc
    (n % m) < abs m : int.mod_lt n (ne_of_gt h)
    ... = m : abs_of_pos h,
  exact ‚ü®HH , ‚ü®HH1, HH2‚ü©‚ü©,
end

instance : has_coe_t ‚Ü•S ùîº := quotient_add_group.has_coe_t

instance : has_lift_t ‚Ü•S ùîº := coe_to_lift

def P := {e : ùîº | ‚àÉ (f : S) (H : ‚Üëf = e), ‚àÄ n (hn : 0 < n), ‚àÉ p (hp : 0 < p), n < f.1 p}

lemma lemma2 (f : S) (hf : ‚àÄ n (hn : 0 < n), ‚àÉ p (hp : 0 < p), n < f.1 p) :
  (‚àÄ C (HC : 0 < C), ‚àÉ N : ‚Ñ§, ‚àÄ p (hNp : N < p), C < f.1 p) :=
begin
  rcases f.2 with ‚ü®D, hD‚ü©,
  have hD1 : ‚àÄ (p q : ‚Ñ§), abs (df f.1 p q) < D := hD,
  specialize hD 1 2,
  have hD' : 0 < D,
    linarith [abs_nonneg (df f.1 1 2)],
  rcases lemma1 f.2 hf D hD' with ‚ü®M, hM0, hM‚ü©,
  have hE : ‚àÉ E, ‚àÄ r (h0r : 0 ‚â§ r) (hrM : r < M), abs(f.1 r) < E,
    have hfin : set.finite ((abs ‚àò f.1) '' (set.Ico 0 M)),
      apply set.finite.image,
      split,
      apply fintype.of_finset (finset.Ico_‚Ñ§ 0 M),
      simp,
    have hbdd : bdd_above ((abs ‚àò f.1) '' (set.Ico 0 M)),
      apply set.finite.bdd_above hfin,
    cases hbdd with m hm,
    unfold upper_bounds at hm,
    simp at hm,
    use m + 1,
    intros r h0r hrM,
    specialize @hm (abs (f.1 r)) r h0r hrM rfl,
    linarith,
  cases hE with E hE,
  have hE1 : ‚àÄ (r : ‚Ñ§), 0 ‚â§ r ‚Üí r < M ‚Üí abs (f.1 r) < E := hE,
  specialize hE 0 _ _,
  { set B := E + D with hB,
    intros C hC,
    have hBC0 : 0 < B + C,
      linarith [abs_nonneg (f.1 0)],
    have hn : ‚àÉ n (hn0 : n > 0), B + C < (n + 1) * D,
      rcases (QRT (B + C) D hD') with ‚ü®n, r, hnr, h0r, hrD‚ü©,
      rw hnr at hBC0,
      have h0n : 0 ‚â§ n,
        by_contradiction hfalse,
        simp at hfalse,
        have hnn : ‚àÉ (nn : ‚Ñ§) (hnn0 : nn > 0), n = -nn,
          use -n,
          split,
            linarith,
          simp,
        rcases hnn with ‚ü®nn, hnn0, hnn‚ü©,
        rw hnn at hBC0,
        have hDnnr : D * nn ‚â§ r,
          linarith,
        have hDDnn : D ‚â§ D * nn,
          exact (le_mul_iff_one_le_right hD').mpr hnn0,
        linarith,
      use n + 1,
      split,
        linarith,
      have hfinal : (n + 1 + 1) * D = D * n + 2 * D,
        ring,
      rw hfinal,
      linarith,
    rcases hn with ‚ü®n, hn0, hn‚ü©,
    use n * M,
    intros p hp,
    rcases (QRT p M hM0) with ‚ü®d, r, hdr, h0r, hrM‚ü©,
    rw hdr at hp,
    have hndr : (n - d) * M < M,
      linarith,
    have hnd : n - d < 1,
      exact (mul_lt_iff_lt_one_left hM0).mp hndr,
    have hnd' : n ‚â§ d,
      linarith,
    have hd0 : 0 < d,
      linarith,
    have hfdm1 : B + C < f.1 (d * M),
      have hnDdD1 : n + 1 ‚â§ d + 1,
        linarith,
      have hnDdD2 : (n + 1) * D ‚â§ (d + 1) * D,
        exact (mul_le_mul_right hD').mpr hnDdD1,
      linarith [hM d hd0],
    have hfdMr : abs (f.1 p - f.1 (d * M)) < B,
      rw hdr,
      have heq1 : f.1 (M * d + r) = f.1 (M * d) + f.1 (r) + df f.1 (M * d) r,
        simp,
        ring,
      have heq2 : f.1 (d * M) + f.1 r + df f.1 (d * M) r - f.1 (d * M) = f.1 r + df f.1 (d * M) r,
        ring,
      rw [heq1, mul_comm, heq2],
      linarith [hD1 (d * M) r, hE1 r h0r hrM, abs_add (f.1 r) (df f.1 (d * M) r)],
    rw abs_lt at hfdMr,
    linarith, },
  { refl, },
  { exact hM0, },
end

lemma lemma3 (f : S) (hf : ‚àÄ n (hn : n < 0), ‚àÉ p (hp : 0 < p), f.1 p < n) :
  (‚àÄ C (HC : 0 < C), ‚àÉ N : ‚Ñ§, ‚àÄ p (hNp : N < p), f.1 p < -C) := 
begin
  set g := -f with hgf,
  have hfval : ‚àÄ p, (-f).val p = -(f.val p),
    intro p,
    unfold has_neg.neg add_group.neg,
  have key : ‚àÄ (C : ‚Ñ§), 0 < C ‚Üí (‚àÉ (N : ‚Ñ§), ‚àÄ (p : ‚Ñ§), N < p ‚Üí C < g.val p),
    apply lemma2 g,
    simp_rw [hgf, hfval],
    intros n hn,
    have : -n < 0,
      linarith,
    specialize hf (-n) this,
    rcases hf with ‚ü®p, hp, hf‚ü©,
    use [p, hp],
    linarith,
  simp_rw [hgf, hfval] at key,
  rintro C hC,
  specialize key C hC,
  cases key with N key,
  use N,
  intros p hp,
  specialize key p hp,
  linarith,
end

lemma lemma4 (f : S) (hf : ‚àÉ C, ‚àÄ p (hp : 0 ‚â§ p), abs (f.1 p) < C) : ‚àÉ B, ‚àÄ p, abs (f.1 p) < B :=
begin
  cases f.2 with D hD,
  cases hf with C hC,
  have hneg : ‚àÉ C', ‚àÄ p (hp : p < 0), abs (f.1 p) < C',
    use C + D + abs (f.1 0),
    intros p hp,
    have hfp : f.1 p = f.1 0 - f.1 (-p) - df f.1 (-p) p,
      simp,
      ring,
    rw hfp,
    have hnegp : 0 < -p,
      exact neg_pos.mpr hp,
    have hnegp' : 0 ‚â§ -p,
      linarith,
    specialize hC (-p) hnegp',
    specialize hD (-p) p,
    have heq : f.val 0 - f.val (-p) - df f.val (-p) p = f.val 0 + (-f.val (-p)) + (-df f.val (-p) p),
      ring,
    rw heq,
    have habs3 : abs (f.val 0 + -f.val (-p) + -df f.val (-p) p) ‚â§ 
      abs (f.val 0) + abs (-f.val (-p)) + abs (-df f.val (-p) p),
      exact abs_add_three (f.val 0) (-f.val (-p)) (-df f.val (-p) p),
    rw [abs_neg, abs_neg] at habs3,
    linarith [abs_add_three (f.val 0) (-f.val (-p)) (-df f.val (-p) p)],
  cases hneg with C' hC',
  use C + C',
  intro p,
  have hp : 0 ‚â§ p ‚à® p < 0 := le_or_lt 0 p,
  cases hp,
  { specialize hC p hp,
    have hne1 : (-1 : ‚Ñ§) < 0,
      norm_num,
    specialize hC' (-1) hne1,
    linarith [abs_nonneg (f.val (-1))], },
  { specialize hC' p hp,
    have h01 : (0 : ‚Ñ§) < 1,
      norm_num,
    specialize hC 1 h01,
    linarith [abs_nonneg (f.val 1)], },
end

lemma lemma5 (f : S) : (‚àÄ n (hn : 0 < n), ‚àÉ p (hp : 0 < p), n < f.1 p) ‚à® 
  (‚àÄ n (hn : n < 0), ‚àÉ p (hp : 0 < p), f.1 p < n) ‚à® (‚àÉ C, ‚àÄ p (hp : 0 ‚â§ p), abs (f.1 p) < C) :=
begin
  by_cases h1 : ‚àÄ n (hn : 0 < n), ‚àÉ p (hp : 0 < p), n < f.1 p,
    left,
    exact h1,
  by_cases h2 : ‚àÄ n (hn : n < 0), ‚àÉ p (hp : 0 < p), f.1 p < n,
    right,
    left,
    exact h2,
  have h1' : ‚àÉ n (hn : 0 < n), ‚àÄ p (hp : 0 < p), f.1 p ‚â§ n,
    finish,
  have h2' : ‚àÉ n (hn : n < 0), ‚àÄ p (hp : 0 < p), n ‚â§ f.1 p,
    finish,  
  rcases h1' with ‚ü®C1, hC1, h1'‚ü©,
  rcases h2' with ‚ü®C2, hC2, h2'‚ü©,
  right,
  right,
  use abs (C1) + abs (C2) + abs (f.val 0) + 1,
  intros p hp,
  have hfval0 : 0 < f.1 p ‚à® f.1 p ‚â§ 0,
    exact lt_or_ge 0 (f.val p),
  cases hfval0,
  { have habs : abs (f.val p) ‚â§ abs C1 + abs (f.val 0),
      have := eq_or_lt_of_le hp,
      cases this,
        rw ‚Üê this,
        linarith [abs_nonneg C1],
      specialize h1' p this,
      have : abs (f.val p) ‚â§ abs C1,
        apply abs_le_abs h1',
        linarith,
      linarith [abs_nonneg (f.val 0)],
    linarith [abs_nonneg C2], },
  { have hfval0' : f.1 p < 0 ‚à® f.1 p = 0,
      exact lt_or_eq_of_le hfval0,
    cases hfval0',
    { have habs : abs (f.val p) ‚â§ abs C2 + abs (f.val 0),
        have := eq_or_lt_of_le hp,
        cases this,
          rw ‚Üê this,
          linarith [abs_nonneg C2],
        specialize h2' p this,
        have habs : abs (f.val p) ‚â§ abs C2,
          rw abs_of_neg hfval0',
          have hC2 : C2 < 0,
            linarith,
          rw abs_of_neg hC2,
          linarith,
        linarith [abs_nonneg (f.val 0)],
      linarith [abs_nonneg C1], }, 
    { rw hfval0',
      simp only [abs_zero],
      linarith [abs_nonneg C1, abs_nonneg C2, abs_nonneg (f.1 0)], }, },
end

lemma lemma6 (f : S) : (‚àÄ C (HC : 0 < C), ‚àÉ N : ‚Ñ§, ‚àÄ p (hNp : N < p), C < f.1 p) ‚àß 
  (‚àÄ C (HC : 0 < C), ‚àÉ N : ‚Ñ§, ‚àÄ p (hNp : N < p), f.1 p < -C) ‚Üí false :=
begin
  rintro ‚ü®h1, h2‚ü©,
  have h01 : (0 : int) < 1,
    norm_num,
  specialize h1 1 h01,
  specialize h2 1 h01,
  cases h1 with N1 h1,
  cases h2 with N2 h2,
  have hN1 : N1 < abs N1 + abs N2 + 1,
    linarith [abs_nonneg N2, le_abs_self N1],
  have hN2 : N2 < abs N1 + abs N2 + 1,
    linarith [abs_nonneg N1, le_abs_self N2],
  specialize h1 (abs N1 + abs N2 + 1) hN1,
  specialize h2 (abs N1 + abs N2 + 1) hN2,
  linarith,
end

lemma lemma7 (f : S) : (‚àÄ C (HC : 0 < C), ‚àÉ N : ‚Ñ§, ‚àÄ p (hNp : N < p), C < f.1 p) ‚àß 
  (‚àÉ B, ‚àÄ p, abs (f.1 p) < B) ‚Üí false :=
begin
  rintro ‚ü®h1, h2‚ü©,
  cases h2 with B h2,
  have h01 : (0 : int) < 1,
    norm_num,
  have h2' : ‚àÄ (p : ‚Ñ§), abs (f.val p) < B := h2,
  specialize h2' 0,
  have hB : 0 < B,
    linarith [abs_nonneg (f.1 0)],
  specialize h1 B hB,
  cases h1 with N h1,
  have hN : N < N + 1,
    linarith,
  specialize h1 (N + 1) hN,
  specialize h2 (N + 1),
  rw abs_lt at h2,
  linarith,
end

lemma lemma8 (f : S) : (‚àÄ n (hn : 0 < n), ‚àÉ p (hp : 0 < p), n < f.1 p) ‚Üî
  (‚àÄ C (HC : 0 < C), ‚àÉ N : ‚Ñ§, ‚àÄ p (hNp : N < p), C < f.1 p) :=
begin
  split,
  { intro hf,
    exact lemma2 f hf, },
  { cases lemma5 f,
    { intro,
      exact h, },
    { cases h,
      { intro h1,
        exfalso,
        exact lemma6 f ‚ü®h1, lemma3 f h‚ü©, },
      { intro h1,
        exfalso,
        exact lemma7 f ‚ü®h1, lemma4 f h‚ü©, }, }, },
end

lemma lemma9 : ‚àÄ a b ‚àà P, a + b ‚àà P :=
begin
  rintro a b ‚ü®f1, hf1a, h1‚ü© ‚ü®f2, hf2b, h2‚ü©,
  use f1 + f2,
  split,
    rw [‚Üê hf1a, ‚Üê hf2b],
    refl,
  rw lemma8 at *,
  intros C hC,
  specialize h1 C hC,
  specialize h2 C hC,
  cases h1 with M h1,
  cases h2 with N h2,
  use max M N,
  intro p,
  intro hMNp,
  have hMNp': M < p ‚àß N < p,
    rw ‚Üê max_lt_iff,
    exact hMNp,
  specialize h1 p hMNp'.1,
  specialize h2 p hMNp'.2,
  have hfinal : (f1 + f2).val p = f1.val p + f2.val p,
    refl,
  rw hfinal,
  linarith,
end

lemma lemma10 : (0 : ùîº) ‚àà P ‚Üí false :=
begin
  intro hfalse,
  unfold P at hfalse,
  rcases hfalse with ‚ü®f, H, hfalse‚ü©,
  rw lemma8 at hfalse,
  unfold has_zero.zero add_monoid.zero add_group.zero add_comm_group.zero at H,
  rw quotient_add_group.eq at H,
  have hf : -f + 0 ‚àà B,
    unfold has_zero.zero add_monoid.zero add_group.zero,
    exact H,
  simp at hf,
  exact lemma7 f ‚ü®hfalse, hf‚ü©,
end

lemma lemma11 {a : ùîº} : a ‚àà P ‚Üí -a ‚àà P ‚Üí false :=
begin
  unfold P,
  rintro ‚ü®f1, hf1, ha1‚ü© ‚ü®f2, hf2, ha2‚ü©,
  rw ‚Üê hf1 at hf2,
  have hf1f2 : ‚Üëf2 + ‚Üëf1 = (0 : ùîº), 
    rw hf2,
    simp,
  have hf1f2' : (@coe ‚Ü•S ùîº) eudoxus_reals_group.has_lift_t (0 : S) = ‚Üë(f2 + f1), 
    have heq : (@coe ‚Ü•S ùîº) eudoxus_reals_group.has_lift_t (f2 + f1) = ‚Üëf2 + ‚Üëf1,
      refl,
    have h0 : (@coe ‚Ü•S ùîº) eudoxus_reals_group.has_lift_t (0 : S) = (0 : ùîº),
      refl,
    rw [heq, h0, ‚Üê hf1f2],
  rw quotient_add_group.eq at hf1f2',
  simp at hf1f2',
  unfold B at hf1f2',
  cases hf1f2' with C hf1f2',
  rw lemma8 at *,
  have h0C : 0 < C,
    linarith [hf1f2' 0, abs_nonneg ((f2 + f1).val 0)],
  cases ha1 C h0C with N1 ha1,
  cases ha2 C h0C with N2 ha2,
  have hN1 : N1 < max N1 N2 + 1,
    linarith [le_max_left N1 N2],
  have hN2 : N2 < max N1 N2 + 1,
    linarith [le_max_right N1 N2],
  specialize ha1 (max N1 N2 + 1) hN1,
  specialize ha2 (max N1 N2 + 1) hN2,
  specialize hf1f2' (max N1 N2 + 1),
  have heq : (f2 + f1).val (max N1 N2 + 1) = f2.val (max N1 N2 + 1) + f1.val (max N1 N2 + 1) := rfl,
  rw [heq, abs_lt] at hf1f2',
  linarith,
end

lemma lemma12 : ‚àÄ a : ùîº, ‚àÉ f : S, ‚Üëf = a := Œª a, quot.exists_rep a

lemma lemma13 : ‚àÄ {f : ‚Ñ§ ‚Üí ‚Ñ§} (C : ‚Ñ§), set.finite (f '' (set.Ioo (-C) C)) :=
begin
  intros f C,
  apply set.finite.image,
  exact ‚ü®fintype.of_finset (finset.Ico_‚Ñ§ (-C + 1) (C)) (by {simp [int.add_one_le_iff]})‚ü©,
end

lemma lemma14 : ‚àÄ f g : S, f.1 ‚àò g.1 ‚àà S :=
begin
  intros f g,
  rcases f with ‚ü®f, C1, hf‚ü©,
  rcases g with ‚ü®g, C2, hg‚ü©,
  simp,
  have hfin : set.finite (f '' (set.Ioo (-C2) (C2))) := lemma13 C2,
  cases set.finite.bdd_above hfin with C3 hC3,
  unfold upper_bounds at hC3,
  simp at hC3,
  cases set.finite.bdd_below hfin with C4 hC4,
  unfold lower_bounds at hC4,
  simp at hC4,
  use C1 + C1 + max (abs (C4)) (abs (C3)),
  unfold df at *,
  intros p q,
  have hf' := hf,
  set t := g (p + q) - g p - g q with ht,
  have heq : g (p + q) = t + (g p + g q),
    rw ht,
    ring,
  specialize hf (g p) (g q),
  specialize hg p q,
  specialize hf' t (g p + g q),
  rw [‚Üê ht, abs_lt] at hg,
  specialize @hC3 (f t) t hg.1 hg.2 rfl,
  specialize @hC4 (f t) t hg.1 hg.2 rfl,
  rw ‚Üê heq at hf',
  have h123 : abs ((f (g p + g q) - f (g p) - f (g q)) + (f (g (p + q)) - f t - f (g p + g q)) + f t)
    ‚â§ abs (f (g p + g q) - f (g p) - f (g q)) + abs (f (g (p + q)) - f t - f (g p + g q)) + abs (f t),
    exact abs_add_three (f (g p + g q) - f (g p) - f (g q)) (f (g (p + q)) - f t - f (g p + g q)) (f t),
  have heq : (f (g p + g q) - f (g p) - f (g q)) + (f (g (p + q)) - f t - f (g p + g q)) + f t = 
    (f ‚àò g) (p + q) - (f ‚àò g) p - (f ‚àò g) q,
    ring,
  rw heq at h123,
  have hft : abs (f t) ‚â§ max (abs (C4)) (abs (C3)),
    apply abs_le_max_abs_abs hC4 hC3,
  linarith,
end

lemma lemma15 : ‚àÄ {f1 g1 f2 g2 : S}, (@coe ‚Ü•S ùîº) eudoxus_reals_group.has_lift_t f1 = ‚Üëf2 ‚Üí 
  (@coe ‚Ü•S ùîº) eudoxus_reals_group.has_lift_t g1 = ‚Üëg2 ‚Üí -(‚ü®f1.1 ‚àò g1.1, lemma14 f1 g1‚ü© : S) 
  + (‚ü®f2.1 ‚àò g2.1, lemma14 f2 g2‚ü© : S) ‚àà B :=
begin
  rintros ‚ü®f1, hf1‚ü© ‚ü®g1, hfg‚ü© ‚ü®f2, Bf2, hf2‚ü© ‚ü®g2, hg2‚ü© hf1f2 hg1g2,
  rw quotient_add_group.eq at *,
  unfold B at *,
  cases hf1f2 with Cf hf1f2,
  cases hg1g2 with Cg hg1g2,
  have hfin : set.finite (f2 '' (set.Ioo (-Cg) (Cg))) := lemma13 Cg,
  cases set.finite.bdd_above hfin with C3 hC3,
  unfold upper_bounds at hC3,
  simp at hC3,
  cases set.finite.bdd_below hfin with C4 hC4,
  unfold lower_bounds at hC4,
  simp at hC4,
  use Cf + Bf2 + max (abs (C4)) (abs (C3)),
  unfold df at hf2,
  intros x,
  set t := (g1 x).neg + g2 x with ht,
  have htrivial : ‚àÄ (a : ‚Ñ§), a.neg = -a, 
    intro a, 
    refl,
  have heq : g2 x = t + g1 x,
    have := htrivial (g1 x),
    rw [ht, this],
    ring,
  specialize hf1f2 (g1 x),
  specialize hg1g2 x,
  specialize hf2 t (g1 x),
  unfold has_add.add add_semigroup.add add_semigroup.add add_monoid.add add_group.add 
    has_neg.neg add_group.neg at hf1f2,
  simp at hf1f2,
  unfold has_add.add add_semigroup.add add_semigroup.add add_monoid.add add_group.add 
    has_neg.neg add_group.neg at hg1g2,
  simp at hg1g2,
  rw [‚Üê ht, abs_lt] at hg1g2,
  specialize @hC3 (f2 t) t hg1g2.1 hg1g2.2 rfl,
  specialize @hC4 (f2 t) t hg1g2.1 hg1g2.2 rfl,
  rw ‚Üê heq at hf2,
  unfold has_add.add add_semigroup.add add_semigroup.add add_monoid.add add_group.add 
    has_neg.neg add_group.neg,
  simp,
  have h123 := abs_add_three ((f1 (g1 x)).neg + f2 (g1 x)) (f2 (g2 x) - f2 t - f2 (g1 x)) (f2 t),
  have heq : ((f1 (g1 x)).neg + f2 (g1 x)) + (f2 (g2 x) - f2 t - f2 (g1 x)) + f2 t = 
    (f1 (g1 x)).neg + f2 (g2 x),
    have hf1g1n := htrivial (f1 (g1 x)),
    rw hf1g1n,
    ring,
  rw heq at h123,
  have hft : abs (f2 t) ‚â§ max (abs (C4)) (abs (C3)),
    apply abs_le_max_abs_abs hC4 hC3,
  linarith,
end

lemma lemma16 : (id : ‚Ñ§ ‚Üí ‚Ñ§) ‚àà S := 
begin
  use 1,
  intros p q,
  simp,
end

noncomputable def ùîº.mul : ùîº ‚Üí ùîº ‚Üí ùîº := Œª a b, 
begin
  choose f hf using lemma12 a,
  choose g hg using lemma12 b,
  let h : ‚Ü•S := ‚ü®f.1 ‚àò g.1, lemma14 f g‚ü©,
  exact ‚Üëh,
end

lemma lemma17 : ‚àÄ x y : S, ùîº.mul ‚Üëx ‚Üëy = ‚Üë(‚ü®x.1 ‚àò y.1, lemma14 x y‚ü© : S) :=
begin
  intros x y,
  unfold ùîº.mul,
  rw quotient_add_group.eq,
  have hxeq := classical.some_spec (lemma12 ‚Üëx),
  have hyeq := classical.some_spec (lemma12 ‚Üëy),
  apply lemma15 hxeq hyeq,
end

lemma lemma18 : ‚àÄ x y : S, x = y ‚Üí -x + y ‚àà B :=
begin
  intros x y hxy,
  rw hxy,
  simp,
  use 1,
  intro p,
  simp,
end

lemma lemma19 (f : S) : ‚àÉ C, ‚àÄ p (H : 0 ‚â§ p) q, abs (f.1 (p * q) - p * (f.1 q)) < (abs p + 1) * C :=
begin
  cases f.2 with C hC,
  use C,
  intros p H,
  induction p,
  { induction p with p hp,
    { intro q,
      simp,
      change abs (f.1 0) < C,
      have hf0 : abs (f.1 0) = abs (f.1 (0 + 0) - f.1 0 - f.1 0),
        simp,
      have hdf0 : df f.1 0 0 = f.1 (0 + 0) - f.1 0 - f.1 0 := rfl,
      rw [hf0, ‚Üê hdf0],
      exact hC 0 0, },
    { intro q,
      specialize hp (int.of_nat_nonneg p) q,
      have hkey : f.val (int.of_nat p.succ * q) - f.1 (p * q) - f.1 q = df f.1 (p * q) q,
        simp,
        ring,
      specialize hC (p * q) q,
      rw ‚Üê hkey at hC,
      have heq : f.val (int.of_nat p.succ * q) - int.of_nat p.succ * f.val q = 
        (f.val (int.of_nat p.succ * q) - f.val (‚Üëp * q) - f.val q) + (f.val (int.of_nat p * q) - 
        int.of_nat p * f.val q),
        simp,
        ring,
      rw heq,
      have : (abs (int.of_nat p.succ) + 1) * C = C + (abs (int.of_nat p) + 1) * C,
        have hp1 : 0 < (‚Üëp : ‚Ñ§) + 1,
          linarith,
        simp,
        rw [abs_of_pos hp1],
        ring,
      linarith [abs_add (f.val (int.of_nat p.succ * q) - f.val (‚Üëp * q) - f.val q) (f.val (int.of_nat p * q) - 
        int.of_nat p * f.val q)], }, },
    { exfalso,
      linarith [int.neg_succ_lt_zero p], },
end

lemma lemma20 (f : S) : ‚àÉ C, ‚àÄ p (H : 0 ‚â§ p) q, abs (f.1 ((-p) * q) - (-p) * (f.1 q)) < (abs (-p) + 1) * C :=
begin
  cases f.2 with C hC,
  use C,
  intros p H,
  induction p,
  { induction p with p hp,
    { intro q,
      simp,
      change abs (f.1 0) < C,
      have hf0 : abs (f.1 0) = abs (f.1 (0 + 0) - f.1 0 - f.1 0),
        simp,
      have hdf0 : df f.1 0 0 = f.1 (0 + 0) - f.1 0 - f.1 0 := rfl,
      rw [hf0, ‚Üê hdf0],
      exact hC 0 0, },
    { intro q,
      specialize hp (int.of_nat_nonneg p) q,
      have hkey : -f.1 (-int.of_nat p.succ * q) + f.1 (-(p * q)) - f.1 q = df f.1 (-(p + 1) * q) q,
        simp,
        have heq : (-1 + -‚Üëp) * q + q = -(‚Üëp * q),
          ring,
        rw heq,
        ring,
      specialize hC (-(‚Üëp + 1) * q) q,
      rw ‚Üê hkey at hC,
      have heq : f.val (-int.of_nat p.succ * q) - -int.of_nat p.succ * f.val q = 
        -(-f.val (-int.of_nat p.succ * q) + f.val (-(p * q)) - f.val q) + (f.val (-int.of_nat p * q) - 
        -int.of_nat p * f.val q),
        simp,
        ring,
      rw heq,
      have : (abs (-int.of_nat p.succ) + 1) * C = C + (abs (-int.of_nat p) + 1) * C,
        have hp1 : 0 ‚â§ (‚Üëp : ‚Ñ§) := int.of_nat_nonneg p,
        have hp2 : -1 + -(‚Üëp : ‚Ñ§) < 0,
          linarith,
        simp,
        rw [abs_of_neg hp2],
        ring,
      have := abs_add (-(-f.val (-int.of_nat p.succ * q) + f.val (-(p * q)) - f.val q)) (f.val (-int.of_nat p * q) - 
        -int.of_nat p * f.val q),
      rw abs_neg at this,
      linarith, }, },
    { exfalso,
      linarith [int.neg_succ_lt_zero p], },
end

lemma lemma21 (f : S) : ‚àÉ C, ‚àÄ p q,  abs (f.1 (p * q) - p * (f.1 q)) < (abs p + 1) * C :=
begin
  cases lemma19 f with C1 hC1,
  cases lemma20 f with C2 hC2,
  use max C1 C2,
  intro p,
  have hp0 := le_or_lt 0 p,
  cases hp0,
  { intro q,
    specialize hC1 p hp0 q,
    have := le_max_left C1 C2,
    have h0abs : 0 < abs p + 1,
      linarith [abs_nonneg p],
    have : (abs p + 1) * C1 ‚â§ (abs p + 1) * max C1 C2,
      have := @mul_le_mul_left ‚Ñ§ (linear_ordered_ring.to_linear_ordered_semiring) C1 (max C1 C2) (abs p + 1),
      rw this,
        exact le_max_left C1 C2,
      linarith,
    linarith, },
  { intro q,
    set np := -p with hnp,
    have hnp0 : 0 ‚â§ np,
      linarith,
    specialize hC2 np hnp0 q,
    have hnpp : -np = p,
      rw hnp,
      simp,
    rw hnpp at hC2,
    have := le_max_left C1 C2,
    have h0abs : 0 < abs p + 1,
      linarith [abs_nonneg p],
    have : (abs p + 1) * C2 ‚â§ (abs p + 1) * max C1 C2,
      have := @mul_le_mul_left ‚Ñ§ (linear_ordered_ring.to_linear_ordered_semiring) C2 (max C1 C2) (abs p + 1),
      rw this,
        exact le_max_right C1 C2,
      linarith,
    linarith, },
end

lemma lemma22 (f : S) : ‚àÉ C, ‚àÄ p q, abs (p * (f.1 q) - q * (f.1 p)) < (abs p + abs q + 2) * C :=
begin
  cases lemma21 f with C hC,
  use C,
  intros p q,
  have hC' := hC,
  specialize hC p q,
  specialize hC' q p,
  rw ‚Üê abs_neg at hC,
  have heq1 : (-(f.val (p * q) - p * f.val q)) + (f.val (q * p) - q * f.val p) = p * f.val q - q * f.val p,
    rw mul_comm,
    ring,
  have heq2 : (abs p + abs q + 2) * C = ((abs p + 1) * C) + ((abs q + 1) * C),
    ring,
  rw [‚Üê heq1, heq2],
  linarith [abs_add (-(f.val (p * q) - p * f.val q)) (f.val (q * p) - q * f.val p)],
end

lemma lemma23 (f : S) : ‚àÉ A B (hA : 0 < A), ‚àÄ p, abs (f.1 p) < A * abs p + B :=
begin
  cases lemma22 f with C hC,
  have hC0 : 0 < C + abs (f.1 1),
    specialize hC 0 0,
    simp at hC,
    linarith [abs_nonneg (f.1 1)],
  use [C + abs (f.1 1), 3 * C, hC0],
  intro p,
  specialize hC p 1,
  have heq1 : f.1 p = -(p * f.1 1 - f.1 p) + (p * f.1 1),
    ring,
  have heq2 : (C + abs (f.val 1)) * abs p + 3 * C = (abs p + 1 + 2) * C + abs (p * f.1 1),
    have : abs (p * f.1 1) = (abs p) * abs (f.1 1) := abs_mul p (f.1 1),
    rw this,
    ring,
  rw [heq1, heq2],
  simp at hC,
  change abs (p * f.1 1 - f.1 p) < (abs p + 1 + 2) * C at hC,
  rw ‚Üê abs_neg at hC,
  linarith [abs_add (-(p * f.val 1 - f.val p)) (p * f.1 1)],
end

lemma lemma24 (f g : S) : ‚àÉ D E, ‚àÄ p, abs p * abs (f.1 (g.1 p) - g.1 (f.1 p)) < D * abs p + E :=
begin
  have h1 : ‚àÉ C, ‚àÄ p, abs (p * f.1 (g.1 p) - g.1 p * f.1 p) < (abs p + abs (g.1 p) + 2) * C,
    cases lemma22 f with C hC,
    use C,
    intro p,
    specialize hC p (g.1 p),
    exact hC,
  have h2 : ‚àÉ C, ‚àÄ p, abs (g.1 p * f.1 p - p * g.1 (f.1 p)) < (abs p + abs (f.1 p) + 2) * C,
    cases lemma22 g with C hC,
    use C,
    intro p,
    specialize hC p (f.1 p),
    have heq : p * g.val (f.val p) - f.val p * g.val p = -(g.val p * f.val p - p * g.val (f.val p)),
      ring,
    rw [heq, abs_neg] at hC,
    exact hC,
  have h3 : ‚àÉ C, ‚àÄ p, abs (p * f.1 (g.1 p) - p * g.1 (f.1 p)) < (2 * abs p + abs (g.1 p) + abs (f.1 p) + 4) * C,
    cases h1 with C1 h1,
    cases h2 with C2 h2,
    use max C1 C2,
    intro p,
    specialize h1 p,
    specialize h2 p,
    have h0abs1 : 0 < abs p + abs (g.val p) + 2,
      linarith [abs_nonneg p, abs_nonneg (g.val p)],
    have h0abs2 : 0 < abs p + abs (f.val p) + 2,
      linarith [abs_nonneg p, abs_nonneg (f.val p)],
    have : (abs p + abs (g.val p) + 2) * C1 ‚â§ (abs p + abs (g.val p) + 2) * max C1 C2,
      have := @mul_le_mul_left ‚Ñ§ (linear_ordered_ring.to_linear_ordered_semiring) C1 (max C1 C2) (abs p + abs (g.val p) + 2),
      rw this,
        exact le_max_left C1 C2,
      linarith,
    have : (abs p + abs (f.val p) + 2) * C2 ‚â§ (abs p + abs (f.val p) + 2) * max C1 C2,
      have := @mul_le_mul_left ‚Ñ§ (linear_ordered_ring.to_linear_ordered_semiring) C2 (max C1 C2) (abs p + abs (f.val p) + 2),
      rw this,
        exact le_max_right C1 C2,  
      linarith,    
    have heq1 : (2 * abs p + abs (g.val p) + abs (f.val p) + 4) * max C1 C2 = 
      (abs p + abs (g.val p) + 2) * max C1 C2 + (abs p + abs (f.val p) + 2) * max C1 C2,
      ring,
    have heq2 : p * f.val (g.val p) - p * g.val (f.val p) = (p * f.1 (g.1 p) - g.1 p * f.1 p) +
      (g.1 p * f.1 p - p * g.1 (f.1 p)),
      ring,
    rw [heq1, heq2],
    linarith [abs_add (p * f.1 (g.1 p) - g.1 p * f.1 p) (g.1 p * f.1 p - p * g.1 (f.1 p))],
  cases h3 with C h3,
  rcases lemma23 f with ‚ü®Af, Bf, hAf, hABf‚ü©,
  rcases lemma23 g with ‚ü®Ag, Bg, hAg, hABg‚ü©,  
  have h4 : ‚àÄ (p : ‚Ñ§), abs (p * f.val (g.val p) - p * g.val (f.val p)) < 
    (2 * abs p + (Ag * abs p + Bg) + (Af * abs p + Bf) + 4) * C,
    intro p,
    specialize hABf p,
    specialize hABg p,
    specialize h3 p,
    have h0abs : 0 < (2 * abs p + abs (g.val p) + abs (f.val p) + 4),
      linarith [abs_nonneg p, abs_nonneg (g.val p), abs_nonneg (f.val p)],
    have : (2 * abs p + abs (g.val p) + abs (f.val p) + 4) * C < 
      (2 * abs p + (Ag * abs p + Bg) + (Af * abs p + Bf) + 4) * C,
      have hfvalgval : (2 * abs p + abs (g.val p) + abs (f.val p) + 4) < 
        (2 * abs p + (Ag * abs p + Bg) + (Af * abs p + Bf) + 4),
        linarith,
      apply mul_lt_mul hfvalgval (le_refl C),
        have := abs_nonneg (p * f.val (g.val p) - p * g.val (f.val p)),
        have h0mul : 0 < (2 * abs p + abs (g.val p) + abs (f.val p) + 4) * C,
          linarith,
        have : 0 < C,
          exact (zero_lt_mul_left h0abs).mp h0mul,
        linarith,
      linarith, 
    linarith,
  use [(2 + Ag + Af) * C, (Bg + Bf + 4) * C],
  intro p,
  specialize h4 p,
  have heq1 : (2 * abs p + (Ag * abs p + Bg) + (Af * abs p + Bf) + 4) * C = 
    (2 * abs p + (Ag * abs p + Bg) + (Af * abs p + Bf) + 4) * C,
    ring,
  have heq2 : abs p * abs (f.val (g.val p) - g.val (f.val p)) = 
    abs (p * f.val (g.val p) - p * g.val (f.val p)),
    have := (abs_mul p (f.val (g.val p) - g.val (f.val p))).symm,
    convert this,
    ring,
  linarith,
end

lemma lemma25 (f g : S) : -(‚ü®f.1 ‚àò g.1, lemma14 f g‚ü© : S) + (‚ü®g.1 ‚àò f.1, lemma14 g f‚ü© : S) ‚àà B :=
begin
  rcases lemma24 f g with ‚ü®D, E, hDE‚ü©,
  simp,
  unfold has_add.add add_semigroup.add add_monoid.add add_group.add has_neg.neg add_group.neg,
  simp,
  change ‚àÉ (C : ‚Ñ§), ‚àÄ (p : ‚Ñ§), abs (-(f.1 (g.1 p)) + g.1 (f.1 p)) < C,
  have h1 : ‚àÄ p (H : abs E < abs p), abs (f.val (g.val p) - g.val (f.val p)) < D + 1,
    intros p hp,
    specialize hDE p,
    have hDE' : abs p * abs (f.val (g.val p) - g.val (f.val p)) < D * abs p + abs E,
      linarith [le_abs_self E],
    have : abs p * abs (f.val (g.val p) - g.val (f.val p)) < abs p * (D + 1),
      linarith,
    have habsp : abs p > 0, 
      linarith [abs_nonneg E],
    have hiff := @mul_lt_mul_left ‚Ñ§ (linear_ordered_ring.to_linear_ordered_semiring) (abs (f.val (g.val p) - g.val (f.val p)))
      (D + 1) (abs p) habsp,
    rw ‚Üê hiff,
    exact this,
  have hB : ‚àÉ B, ‚àÄ (p : ‚Ñ§), abs p ‚â§ abs E ‚Üí abs (f.val (g.val p) - g.val (f.val p)) < B,
    have hfin : set.finite ((Œª p, abs (f.val (g.val p) - g.val (f.val p))) '' (set.Icc (-(abs E)) (abs E))),
      apply set.finite.image,
      exact ‚ü®fintype.of_finset (finset.Ico_‚Ñ§ (-(abs E)) (abs E + 1)) (by {simp [int.lt_add_one_iff]})‚ü©,
    have hbdd : bdd_above ((Œª p, abs (f.val (g.val p) - g.val (f.val p))) '' (set.Icc (-(abs E)) (abs E))),
      apply set.finite.bdd_above hfin,
    cases hbdd with m hm,
    unfold upper_bounds at hm,
    simp at hm,
    use m + 1,
    intros p hpE,
    rw abs_le at hpE,
    specialize @hm (abs (f.val (g.val p) - g.val (f.val p))) p hpE.1 hpE.2 rfl,
    linarith,
  cases hB with B hB,
  use max B (D + 1),
  intro p,
  rw ‚Üê abs_neg,
  have : -(-f.val (g.val p) + g.val (f.val p)) = f.val (g.val p) - g.val (f.val p),
    ring,
  rw this,
  have hpE := le_or_lt (abs p) (abs E),
  cases hpE,
    specialize hB p hpE,
    linarith [le_max_left B (D + 1)],
  specialize h1 p hpE,
  linarith [le_max_right B (D + 1)],
end

lemma ùîº.mul_comm : ‚àÄ (a b : ùîº), ùîº.mul a b = ùîº.mul b a :=
begin
  intros a b,
  cases lemma12 a with u hu,
  cases lemma12 b with v hv,
  rw [‚Üê hu, ‚Üê hv, lemma17 u v, lemma17 v u, quotient_add_group.eq],
  apply lemma25,
end

lemma ùîº.mul_right_distrib : ‚àÄ (a b c : ùîº), ùîº.mul (a + b) c = ùîº.mul a c + ùîº.mul b c :=
begin
  intros a b c,
  cases lemma12 a with u hu,
  cases lemma12 b with v hv,
  cases lemma12 c with w hw,
  have H1 := lemma17 (u + v) w,
  have H2 := lemma17 u w,
  have H3 := lemma17 v w,
  have heq : ‚àÄ v w, (@coe ‚Ü•S ùîº) eudoxus_reals_group.has_lift_t (v + w) = 
    @has_add.add ùîº (@add_semigroup.to_has_add ùîº (add_monoid.to_add_semigroup ùîº)) ‚Üëv ‚Üëw := Œª v w, rfl,
  rw heq at H1,
  rw [‚Üê hu, ‚Üê hv, ‚Üê hw],
    rw [H1, H2, H3, ‚Üê heq, quotient_add_group.eq],
    simp,
    apply lemma18,
    unfold has_add.add add_semigroup.add add_monoid.add add_group.add,
    simp,
end

noncomputable instance comm_ring_ùîº : comm_ring ùîº := {
  mul := ùîº.mul,
  mul_assoc := begin
    intros a b c,
    cases lemma12 a with u hu,
    cases lemma12 b with v hv,
    cases lemma12 c with w hw,
    set ab : ‚Ü•S := ‚ü®u.1 ‚àò v.1, lemma14 u v‚ü© with hab, 
    set abc : ‚Ü•S := ‚ü®ab.1 ‚àò w.1, lemma14 ab w‚ü© with habc,
    set bc : ‚Ü•S := ‚ü®v.1 ‚àò w.1, lemma14 v w‚ü© with hbc,
    set abc' : ‚Ü•S := ‚ü®u.1 ‚àò bc.1, lemma14 u bc‚ü© with habc',  
    have H1 := lemma17 u v,
    have H2 := lemma17 ab w,
    have H3 := lemma17 v w,
    have H4 := lemma17 u bc,
    rw [hu, hv] at H1,
    rw [hab, ‚Üê habc, ‚Üê H1, hw] at H2,
    rw [hv, hw] at H3,
    rw [hbc, ‚Üê habc', ‚Üê H3, hu] at H4,
    unfold has_mul.mul,
    rw [H2, H4],
  end,
  one := ‚Üë(‚ü®(id : ‚Ñ§ ‚Üí ‚Ñ§), lemma16‚ü© : S),
  one_mul := begin
    intro a,
    cases lemma12 a with u hu,
    rw ‚Üê hu,
    unfold has_one.one has_mul.mul semigroup.mul ùîº.mul,
    simp,
    rw quotient_add_group.eq,
    have h1 := classical.some_spec (lemma12 ‚Üëu),
    have h2 := classical.some_spec (lemma12 ‚Üë(‚ü®(id : ‚Ñ§ ‚Üí ‚Ñ§), lemma16‚ü© : S)),
    have h3 := lemma15 h2 h1,
    have h4 : u = (‚ü®(‚ü®(id : ‚Ñ§ ‚Üí ‚Ñ§), lemma16‚ü© : S).val ‚àò u.val, lemma14 ‚ü®(id : ‚Ñ§ ‚Üí ‚Ñ§), lemma16‚ü© u‚ü© : S),
      simp,
    rw h4,
    convert h3,
    simp,
  end,
  mul_one := begin
    intro a,
    cases lemma12 a with u hu,
    rw ‚Üê hu,
    unfold has_one.one has_mul.mul semigroup.mul ùîº.mul,
    simp,
    rw quotient_add_group.eq,
    have h1 := classical.some_spec (lemma12 ‚Üëu),
    have h2 := classical.some_spec (lemma12 ‚Üë(‚ü®(id : ‚Ñ§ ‚Üí ‚Ñ§), lemma16‚ü© : S)),
    have h3 := lemma15 h1 h2,
    have h4 : u = (‚ü®(‚ü®(id : ‚Ñ§ ‚Üí ‚Ñ§), lemma16‚ü© : S).val ‚àò u.val, lemma14 ‚ü®(id : ‚Ñ§ ‚Üí ‚Ñ§), lemma16‚ü© u‚ü© : S),
      simp,
    rw h4,
    convert h3,
    simp,
  end,
  left_distrib := begin
    intros a b c,
    unfold has_mul.mul,
    rw [ùîº.mul_comm],
    have := ùîº.mul_comm a c,
    symmetry,
    rw [ùîº.mul_comm, this],
    symmetry,
    apply ùîº.mul_right_distrib,
  end,
  right_distrib := begin
    intros a b c,
    unfold has_mul.mul,
    apply ùîº.mul_right_distrib,
  end, 
  mul_comm := begin
    intros a b,
    unfold has_mul.mul,
    apply ùîº.mul_comm,
  end,
  ..add_comm_group_ùîº }

lemma lemma26 {f : ‚Ñ§ ‚Üí ‚Ñ§} : (‚àÄ p < 0, f p = -(f (-p))) ‚Üí (‚àÉ C, ‚àÄ m n (hm : 0 ‚â§ m) (hn : 0 ‚â§ n),
  abs (df f m n) < C) ‚Üí f ‚àà S :=
begin
  rintro h1 ‚ü®C, h2‚ü©,
  use C,
  intros p q,
  have hp := le_or_lt 0 p,
  have hq := le_or_lt 0 q,
  cases hp,
  { cases hq,
      exact h2 p q hp hq,
    have hpq := le_or_lt 0 (p + q),
    cases hpq,
      have h0q : 0 ‚â§ -q,
        linarith,
      simp,
      specialize h2 (p + q) (-q) hpq h0q,
      simp at h2,
      have : -(f (p + q) - f p - -f (-q)) = f p - f (p + q) - f (-q),
        ring,
      rw [h1 q hq, ‚Üê abs_neg, this],
      exact h2, 
    have hpq' : 0 ‚â§ -(p + q),
      linarith,
    specialize h2 (-(p + q)) p hpq' hp,
    simp at h2,
    simp,
    have : -f (-(p + q)) - f p - -f (-q) = f (-q) - f (-q + -p) - f p,
      have : -(p + q) = -q + -p,
        ring,
      rw this,
      ring,
    rw [h1 q hq, h1 (p + q) hpq, this],
    exact h2, },
  cases hq,
  { have hpq := le_or_lt 0 (p + q),
    cases hpq,
      have h0p : 0 ‚â§ -p,
        linarith,
      simp,
      specialize h2 (p + q) (-p) hpq h0p,
      simp at h2,
      have : -(f (p + q) - -f (-p) - f q) = f (p + q + -p) - f (p + q) - f (-p),
        have : p + q + -p = q,
          ring,
        rw this,
        ring,
      rw [h1 p hp, ‚Üê abs_neg, this],
      exact h2, 
    have hpq' : 0 ‚â§ -(p + q),
      linarith,
    specialize h2 (-(p + q)) q hpq' hq,
    simp at h2,
    simp,
    have : -f (-(p + q)) - -f (-p) - f q = f (-q + -p + q) - f (-q + -p) - f q,
      have eq1 : -(p + q) = -q + -p,
        ring,
      have eq2 : -q + -p + q = -p,
        ring,
      rw [eq1, eq2],
      ring,
    rw [h1 p hp, h1 (p + q) hpq, this],
    exact h2, },
  have H1 : df f p q = -(df f (-p) (-q)),
    have hpq : p + q < 0,
      linarith,
    have heq : -(p + q) = -p - q,
      ring,
    simp,
    rw [h1 p hp, h1 q hq, h1 (p + q) hpq],
    ring,
    rw heq,
    ring,
  have h0p : 0 ‚â§ -p,
    linarith,
  have h0q : 0 ‚â§ -q,
    linarith,
  specialize h2 (-p) (-q) h0p h0q,
  rw [H1, abs_neg],
  exact h2,
end

lemma lemma27 (S : set ‚Ñ§) : S.nonempty ‚Üí (‚àÄ n : ‚Ñ§, n ‚àà S ‚Üí 0 ‚â§ n) ‚Üí ‚àÉ n ‚àà S, ‚àÄ m ‚àà S, n ‚â§ m := 
begin
  intros H1 H2,
  set S' := {a : ‚Ñï | ‚àÉ (s : ‚Ñ§) (Hs : s ‚àà S), s = ‚Üëa},
  have hS' : S'.nonempty,
    show ‚àÉ (t : ‚Ñï) (s : ‚Ñ§) (Hs : s ‚àà S), s = ‚Üët,
    cases H1 with x hx,
    specialize H2 x hx,
    have := int.eq_coe_of_zero_le H2,
    cases this,
    use [this_w, x, hx, this_h],
  have hS'S : ‚àÄ {a : ‚Ñï}, a ‚àà S' ‚Üí ‚Üëa ‚àà S,
    rintro a ‚ü®a', ha', haa'‚ü©,
    rw ‚Üê haa',
    exact ha',
  use ‚Üë(nat.find_x hS').1,
  cases (nat.find_x hS').2 with h1 h2,
  use hS'S h1,
  intros m hm,
  specialize H2 m hm,
  cases int.eq_coe_of_zero_le H2 with m' hm',
  specialize h2 m',
  have h2' : m' ‚àà S' ‚Üí (nat.find_x hS').val ‚â§ m',
    contrapose,
    simp only [exists_prop, not_le, exists_eq_right],
    exact h2,
  have : m' ‚àà S' := ‚ü®m, hm, hm'‚ü©,
  specialize h2' this,
  rw hm',
  exact int.coe_nat_le.mpr h2',
end

def P' := {f : S | ‚àÄ n (hn : 0 < n), ‚àÉ p (hp : 0 < p), n < f.1 p}

lemma lemma28 (f : P') : ‚àÄ p (hp : 0 ‚â§ p), ‚àÉ n (hn : n ‚àà {m | p ‚â§ f.1.1 m ‚àß 0 ‚â§ m}), ‚àÄ x ‚àà {m | p ‚â§ f.1.1 m ‚àß 0 ‚â§ m}, n ‚â§ x :=
begin
  intros p hp,
  cases f with f hf,
  unfold P' at hf,
  simp only [set.mem_set_of_eq] at hf,
  rw lemma8 f at hf,
  have hp1 : 0 < p + 1,
    linarith,
  specialize hf (p + 1) hp1,
  have hnonempty : {m : ‚Ñ§ | p ‚â§ f.val m ‚àß 0 ‚â§ m}.nonempty,
    cases hf with N hf,
    have hN : N < max 0 (N + 1),
      rw lt_max_iff,
        right,
      linarith,
    specialize hf (max 0 (N + 1)) hN,   
    use (max 0 (N + 1)),
    simp only [set.mem_set_of_eq],
    split, 
      linarith,
    rw le_max_iff,
    left,
    linarith,
  have hall : ‚àÄ n : ‚Ñ§, n ‚àà {m : ‚Ñ§ | p ‚â§ f.val m ‚àß 0 ‚â§ m} ‚Üí 0 ‚â§ n,
    intros n hn,
    exact hn.2,
  exact lemma27 {m : ‚Ñ§ | p ‚â§ f.val m ‚àß 0 ‚â§ m} hnonempty hall,
end

lemma lemma29 (a : ùîº) : a ‚àà P ‚à® a = 0 ‚à® -a ‚àà P :=
begin
  cases lemma12 a with u hu,
  cases lemma5 u,
    left,
    unfold P,
    use [u.1, u.2],
    simp only [subtype.coe_eta, subtype.val_eq_coe],
    use [hu, h],
  cases h,
    right,
    right,
    unfold P,
    have : ‚Üë-u = -a,
      rw ‚Üê hu,
      refl,
    use [-u, this],
    intros n hn,
    have hn0 : -n < 0,
      linarith,
    specialize h (-n) hn0,
    rcases h with ‚ü®p, hp, h‚ü©,
    use [p, hp],
    have huval : (-u).val p = -(u.val p) := rfl,
    linarith,
  right,
  left,
  have : (0 : ùîº) = ‚Üë(0 : S) := rfl,
  symmetry,
  rw [‚Üê hu, this, quotient_add_group.eq],
  simp,
  exact lemma4 u h,
end

lemma lemma30 {a : ùîº} : a ‚àâ P ‚Üí ¬¨(a = 0) ‚Üí -a ‚àà P :=
begin
  intros h1 h2,
  cases lemma29 a,
    exfalso,
    exact h1 h,
  cases h,
    exfalso,
    exact h2 h,
  exact h,
end

noncomputable def ùîº.inv.g1 : P' ‚Üí (‚Ñ§ ‚Üí ‚Ñ§) := Œª f, (Œª p,
if hp : 0 ‚â§ p then begin
  choose n hn using lemma28 f p hp,
  exact n,
end
else begin
  have hp' : 0 ‚â§ -p,
    linarith,
  choose n hn using lemma28 f (-p) hp',
  exact -n,
end)

lemma lemma31 (f : P') :  ‚àÄ n (hn : 0 ‚â§ n), 0 ‚â§ ùîº.inv.g1 f n :=
begin
  intros n hn,
  unfold ùîº.inv.g1,
  split_ifs,
  have := classical.some_spec (lemma28 f n hn),
  cases this with hsome1 hsome2,
  rw set.mem_set_of_eq at hsome1,
  exact hsome1.2,
end

lemma lemma32 (f : P') :  ‚àÉ n (hn : 0 < n), 0 < ùîº.inv.g1 f n :=
begin
  by_contradiction hfalse,
  have hfalse' : ‚àÄ n (hn : 0 < n), ùîº.inv.g1 f n ‚â§ 0,
    rw not_exists at hfalse,
    intros n hn,
    specialize hfalse n,
    rw not_exists at hfalse,
    specialize hfalse hn,
    linarith,
  clear hfalse,
  cases f with f hf,
  unfold P' at hf,
  rw set.mem_set_of_eq at hf,
  have hfalse1 :  ‚àÄ (n : ‚Ñ§), 0 < n ‚Üí ùîº.inv.g1 ‚ü®f, hf‚ü© n = 0,
    intros n hn0,
    specialize hfalse' n hn0,
    have hn0' : 0 ‚â§ n,
      linarith,
    have := lemma31 ‚ü®f, hf‚ü© n hn0',
    exact le_antisymm hfalse' this,
  have hfalse2 : ‚àÄ (n : ‚Ñ§), 0 < n ‚Üí n ‚â§ f.1 0,
    intros n hn,
    specialize hfalse1 n hn,
    unfold ùîº.inv.g1 at hfalse1, 
    split_ifs at hfalse1,
      have hn' : 0 ‚â§ n,
        linarith,
      have := classical.some_spec (lemma28 ‚ü®f, hf‚ü© n hn'),
      cases this with hsome1 hsome2,
      simp at hsome1,
      rw ‚Üê hfalse1,
      simp,
      exact hsome1.1,
    exfalso,
    linarith,
  have hlt : 0 < max (f.val 0 + 1) 1,
    rw lt_max_iff,
      right,
    norm_num,
  specialize hfalse2 (max (f.val 0 + 1) 1) hlt,
  have : (f.val 0 + 1) ‚â§ max (f.val 0 + 1) 1 := le_max_left (f.val 0 + 1) 1,
  linarith,
end

lemma lemma33 (f : P') : ‚àÄ n m (hn : 0 ‚â§ n) (hm : n ‚â§ m), ùîº.inv.g1 f n ‚â§ ùîº.inv.g1 f m :=
begin
  intros n m hn hm,
  unfold ùîº.inv.g1,
  have hm' : 0 ‚â§ m,
    linarith,
  split_ifs,
  have h1 := classical.some_spec (lemma28 f n hn),
  have h2 := classical.some_spec (lemma28 f m hm'),
  set gn := classical.some (lemma28 f n hn) with hgn,
  set gm := classical.some (lemma28 f m hm') with hgm,
  rw ‚Üê hgn at *,
  rw ‚Üê hgm at *,
  cases h1 with h11 h12,
  cases h2 with h21 h22,
  rw set.mem_set_of_eq at *,
  have : n ‚â§ f.val.val gm,
    linarith,
  specialize h12 gm,
  rw set.mem_set_of_eq at h12,
  specialize h12 ‚ü®this, h21.2‚ü©,
  exact h12,
end

lemma lemma34 (f : P') :  ‚àÉ N (HN : 0 < N), ‚àÄ n (hn : N ‚â§ n), 0 < ùîº.inv.g1 f n :=
begin
  rcases lemma32 f with ‚ü®N, hN, h‚ü©,
  have : 0 ‚â§ N,
    linarith,
  use [N, hN],
  intros n hNn,
  have := lemma33 f N n this hNn,
  linarith,
end

lemma lemma35 (f : P') :  ‚àÄ n (hn : 0 ‚â§ n), n ‚â§ f.1.1 (ùîº.inv.g1 f n) :=
begin
  intros n h0n,
  unfold ùîº.inv.g1,
  split_ifs,
  have := classical.some_spec (lemma28 f n h0n),
  set gn := classical.some (lemma28 f n h0n) with hgn,
  rw ‚Üê hgn at *,
  cases this with hgn1 hgn2,
  rw set.mem_set_of_eq at hgn1,
  exact hgn1.1,
end

lemma lemma36 (f g h : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§) {c : ‚Ñ§} {F : P'} : (‚àÄ a b (ha : c ‚â§ a) (hb : 0 ‚â§ b) (hgb : 0 < ùîº.inv.g1 F b), f a b > 0 ‚àß g a b < 0) ‚Üí (‚àÉ C, ‚àÄ a b, abs (h a b - f a b) < C) ‚Üí 
  (‚àÉ D, ‚àÄ a b, abs (h a b - g a b) < D) ‚Üí (‚àÉ E, ‚àÄ a b (ha : c ‚â§ a) (hb : 0 ‚â§ b) (hgb : 0 < ùîº.inv.g1 F b), abs (h a b) < E) :=
begin
  rintro h ‚ü®C, h1‚ü© ‚ü®D, h2‚ü©,
  use C + D,
  intros a b ha hb hgb,
  specialize h a b ha hb hgb,
  specialize h1 a b,
  specialize h2 a b,
  cases h with hf hg,
  rw abs_lt at *,
  cases h1,
  cases h2,
  split,
    linarith,
  linarith,
end

lemma lemma37 (f : P') (T : set ‚Ñ§) : (‚àÉ C, ‚àÄ x ‚àà T, abs (f.1.1 x) < C) ‚Üí (‚àÉ B, ‚àÄ x ‚àà T, abs x ‚â§ B) :=
begin
  rintro ‚ü®C, hC‚ü©,
  by_contradiction hfalse,
  have hfalse' : ‚àÄ (B : ‚Ñ§), ‚àÉ (x : ‚Ñ§), x ‚àà T ‚àß B < abs x,
    rw not_exists at hfalse,
    intro B,
    specialize hfalse B,
    rw not_forall at hfalse,
    cases hfalse with x hx,
    use x,
    rw not_imp at hx,
    use hx.1,
    have := hx.2,
    simp at this,
    exact this,
  clear hfalse,
  cases f with f hf,
  unfold P' at hf,
  rw set.mem_set_of_eq at hf,
  have := lemma2 f hf,
  have hD : ‚àÉ D, ‚àÄ p, abs (f.1 p + f.1 (-p)) < D,
    rcases f with ‚ü®f, E, hE‚ü©,
    use E + abs (f 0),
    intro p,
    specialize hE p (-p),
    rw ‚Üê abs_neg at hE,
    simp at hE,
    simp,
    have heq : f p + f (-p) = (f (-p) - (f 0 - f p)) + f 0,
      ring,
    rw heq,
    linarith [abs_add (f (-p) - (f 0 - f p)) (f 0), le_abs_self (f 0)],
  cases hD with D hD,
  have h0D : 0 < D,
    linarith [hD 0, abs_nonneg (f.1 0 + f.1 (-0))],
  have hCD : 0 < max 0 C + D,
    linarith [le_max_left 0 C],
  specialize this (max 0 C + D) hCD,
  cases this with N hN,
  rcases hfalse' N with ‚ü®x, hxT, hNx‚ü©,
  rw lt_abs at hNx,
  cases hNx,
    specialize hC x hxT,
    specialize hN x hNx,
    simp at hC,
    simp at hN,
    linarith [le_abs_self ((‚Üëf : (‚Ñ§ ‚Üí ‚Ñ§)) x), le_max_left 0 C, le_max_right 0 C],
  specialize hC x hxT,
  specialize hN (-x) hNx,
  specialize hD x,
  simp at hC,
  simp at hN,
  have : abs ((‚Üëf : ‚Ñ§ ‚Üí ‚Ñ§) (-x)) < C + D,
    rw ‚Üê abs_neg at hC,
    simp at hD,
    have : (‚Üëf : ‚Ñ§ ‚Üí ‚Ñ§) (-x) = -(‚Üëf : ‚Ñ§ ‚Üí ‚Ñ§) x + ((‚Üëf : ‚Ñ§ ‚Üí ‚Ñ§) x + (‚Üëf : ‚Ñ§ ‚Üí ‚Ñ§) (-x)),
      ring,
    rw this,
    linarith [abs_add (-(‚Üëf : ‚Ñ§ ‚Üí ‚Ñ§) x) ((‚Üëf : ‚Ñ§ ‚Üí ‚Ñ§) x + (‚Üëf : ‚Ñ§ ‚Üí ‚Ñ§) (-x))],
  linarith [le_abs_self ((‚Üëf : (‚Ñ§ ‚Üí ‚Ñ§)) (-x)), le_max_right 0 C],
end

lemma lemma38 (f : P') : ‚àÉ C, ‚àÄ m n, abs ((f.1.1 (ùîº.inv.g1 f (m + n)) - f.1.1 (ùîº.inv.g1 f m) - f.1.1 (ùîº.inv.g1 f n)) - 
  (f.1.1 (ùîº.inv.g1 f (m + n)) - f.1.1 (ùîº.inv.g1 f m - 1) - f.1.1 (ùîº.inv.g1 f n - 1))) < C :=
begin
  rcases f with ‚ü®‚ü®f, C, hC‚ü©, hf‚ü©,
  use 2 * C + 2 * abs (f 1),
  intros m n,
  simp,
  ring,
  have hC' := hC,
  specialize hC (ùîº.inv.g1 ‚ü®‚ü®f, _‚ü©, hf‚ü© m - 1) 1,
  specialize hC' (ùîº.inv.g1 ‚ü®‚ü®f, _‚ü©, hf‚ü© n - 1) 1,
  simp at hC,
  simp at hC',
  rw abs_lt at *,
  cases hC,
  cases hC',
  split,
    linarith [le_abs_self (f 1)],
  linarith [le_abs_self (-f 1), abs_neg (f 1)],
end

lemma lemma39 (f : P') : ‚àÉ C, ‚àÄ m n, abs ((f.1.1 (ùîº.inv.g1 f (m + n)) - f.1.1 (ùîº.inv.g1 f m) - f.1.1 (ùîº.inv.g1 f n)) - 
  (f.1.1 (ùîº.inv.g1 f (m + n) - 1) - f.1.1 (ùîº.inv.g1 f m) - f.1.1 (ùîº.inv.g1 f n))) < C :=
begin
  rcases f with ‚ü®‚ü®f, C, hC‚ü©, hf‚ü©,
  use C + abs (f 1),
  intros m n,
  simp,
  ring,
  specialize hC (ùîº.inv.g1 ‚ü®‚ü®f, _‚ü©, hf‚ü© (m + n) - 1) 1,
  simp at hC,
  rw abs_lt at *,
  cases hC,
  split,
    linarith [le_abs_self (-f 1), abs_neg (f 1)],
  linarith [le_abs_self (f 1)],
end

lemma lemma40 (f : P') : ‚àÉ C, ‚àÄ m n, abs (f.1.1 (ùîº.inv.g1 f (m + n) - (ùîº.inv.g1 f m) - (ùîº.inv.g1 f n)) - 
  (f.1.1 (ùîº.inv.g1 f (m + n)) - f.1.1 (ùîº.inv.g1 f m) - f.1.1 (ùîº.inv.g1 f n))) < C :=
begin
  rcases f with ‚ü®‚ü®f, C, hC‚ü©, hf‚ü©,
  use 2 * C,
  intros m n,
  have : ‚àÄ p q r, abs (f(r - p - q) - (f r - f p - f q)) < 2 * C,
    intros p q r,
    have hC' := hC,
    specialize hC (r - p - q) (p + q),
    specialize hC' p q,
    simp at hC,
    have heq : r - p - q + (p + q) = r,
      ring,
    rw heq at hC,
    simp at hC',
    rw abs_lt at *,
    cases hC,
    cases hC',
    split,
      linarith,
    linarith,
  exact this (ùîº.inv.g1 ‚ü®‚ü®f, _‚ü©, hf‚ü© m) (ùîº.inv.g1 ‚ü®‚ü®f, _‚ü©, hf‚ü© n) (ùîº.inv.g1 ‚ü®‚ü®f, _‚ü©, hf‚ü© (m + n)),
end

lemma lemma41 (f : P') : ‚àÉ C, ‚àÄ m n, abs (f.1.1 (ùîº.inv.g1 f (m + n) - (ùîº.inv.g1 f m) - (ùîº.inv.g1 f n)) - 
  (f.1.1 (ùîº.inv.g1 f (m + n)) - f.1.1 (ùîº.inv.g1 f m - 1) - f.1.1 (ùîº.inv.g1 f n - 1))) < C :=
begin
  cases lemma38 f with C1 hC1,
  cases lemma40 f with C2 hC2,
  use C1 + C2,
  intros m n,
  specialize hC1 m n,
  specialize hC2 m n,
  rw abs_lt at *,
  split,
    linarith,
  linarith,
end

lemma lemma42 (f : P') : ‚àÉ C, ‚àÄ m n, abs (f.1.1 (ùîº.inv.g1 f (m + n) - (ùîº.inv.g1 f m) - (ùîº.inv.g1 f n)) - 
  (f.1.1 (ùîº.inv.g1 f (m + n) - 1) - f.1.1 (ùîº.inv.g1 f m) - f.1.1 (ùîº.inv.g1 f n))) < C :=
begin
  cases lemma39 f with C1 hC1,
  cases lemma40 f with C2 hC2,
  use C1 + C2,
  intros m n,
  specialize hC1 m n,
  specialize hC2 m n,
  rw abs_lt at *,
  split,
    linarith,
  linarith,
end

lemma lemma43 (f : P') :  ‚àÄ n (hn : 0 ‚â§ n), 0 < ùîº.inv.g1 f n ‚Üí (f.1.1 (ùîº.inv.g1 f n - 1) < n ‚àß n ‚â§ f.1.1 (ùîº.inv.g1 f n)) :=
begin
  intros n h0n h,
  unfold ùîº.inv.g1,
  split,
  { split_ifs,
    have := classical.some_spec (lemma28 f n h0n),
    set gn := classical.some (lemma28 f n h0n) with hgn,
    rw ‚Üê hgn at *,
    cases this with hgn1 hgn2,
    by_contradiction hfgn,
    rw not_lt at hfgn,
    specialize hgn2 (gn - 1),
    have : gn - 1 ‚àà {m : ‚Ñ§ | n ‚â§ f.val.val m ‚àß 0 ‚â§ m},
      rw set.mem_set_of_eq,
      use hfgn,
      unfold ùîº.inv.g1 at h,
      split_ifs at h,
      rw ‚Üê hgn at *,
      linarith,
    specialize hgn2 this,
    linarith, },
  { exact lemma35 f n h0n, },
end

lemma lemma44 (f : P') : ‚àÉ C, ‚àÄ m n (hgn : 0 = ùîº.inv.g1 f n), abs ((f.1.1 (ùîº.inv.g1 f (m + n) - (ùîº.inv.g1 f m) - (ùîº.inv.g1 f n))) - 
  (f.1.1 (ùîº.inv.g1 f (m + n)) - f.1.1 (ùîº.inv.g1 f m - 1))) < C :=
begin
  rcases f with ‚ü®‚ü®f, C, hC‚ü©, hf‚ü©,
  use 2 * C + abs (f 1),
  intros m n hgn,
  rw ‚Üêhgn,
  simp,
  have : ‚àÄ p q, abs (f (p - q) - (f p - f (q - 1))) < 2 * C + abs (f 1),
    intros p q,
    have hC' := hC,
    specialize hC 1 (q - 1),
    specialize hC' (p - q) q,
    simp at hC,
    simp at hC',
    rw abs_lt at *,
    cases hC,
    cases hC',
    split,
      linarith [le_abs_self (f 1)],
    linarith [le_abs_self (-f 1), abs_neg (f 1)],
  specialize this (ùîº.inv.g1 ‚ü®‚ü®f, _‚ü©, hf‚ü© (m + n)) (ùîº.inv.g1 ‚ü®‚ü®f, _‚ü©, hf‚ü© (m)),
  exact this,
end

lemma lemma45 (f g h : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§) {c : ‚Ñ§} {F : P'} : (‚àÄ a b (ha : c ‚â§ a) (hb : 0 ‚â§ b) (hgb : 0 = ùîº.inv.g1 F b), f a b > 0 ‚àß g a b < 0) ‚Üí (‚àÉ C, ‚àÄ a b (hgb : 0 = ùîº.inv.g1 F b),
  abs (h a b - f a b) < C) ‚Üí (‚àÉ D, ‚àÄ a b, abs (h a b - g a b) < D) ‚Üí (‚àÉ E, ‚àÄ a b (ha : c ‚â§ a) (hb : 0 ‚â§ b) (hgb : 0 = ùîº.inv.g1 F b), abs (h a b) < E) :=
begin
  rintro h ‚ü®C, h1‚ü© ‚ü®D, h2‚ü©,
  use C + D,
  intros a b ha hb hgb,
  specialize h a b ha hb hgb,
  specialize h1 a b hgb,
  specialize h2 a b,
  cases h with hf hg,
  rw abs_lt at *,
  cases h1,
  cases h2,
  split,
    linarith,
  linarith,
end

lemma lemma46 (f : P') : ‚àÉ (N : ‚Ñ§) (C : ‚Ñ§) , ‚àÄ (m n : ‚Ñ§), N ‚â§ m ‚Üí 0 ‚â§ n ‚Üí abs (df (Œª (p : ‚Ñ§), ùîº.inv.g1 f p) m n) < C :=
begin
  rcases lemma34 f with ‚ü®N, hN, hfN‚ü©,
  have h1 : ‚àÄ m n (hm : N ‚â§ m) (h0n : 0 ‚â§ n) (hgn : 0 < ùîº.inv.g1 f n), (f.1.1 (ùîº.inv.g1 f m - 1) < m ‚àß m ‚â§ f.1.1 (ùîº.inv.g1 f m)) ‚àß (f.1.1 (ùîº.inv.g1 f n - 1) < n ‚àß 
    n ‚â§ f.1.1 (ùîº.inv.g1 f n)) ‚àß (f.1.1 (ùîº.inv.g1 f (m + n) - 1) < m + n ‚àß m + n ‚â§ f.1.1 (ùîº.inv.g1 f (m + n))),
    intros m n hm h0n hgn,
    have h0m : 0 ‚â§ m,
      linarith,
    have h0mn : 0 ‚â§ m + n,
      linarith,
    have hmn : N ‚â§ m + n,
      linarith,
    use [lemma43 f m h0m (hfN m hm), lemma43 f n h0n hgn, lemma43 f (m + n) h0mn (hfN (m + n) hmn)],
  set f1 : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§ := Œª m n, f.1.1 (ùîº.inv.g1 f (m + n)) - f.1.1 (ùîº.inv.g1 f m - 1) - f.1.1 (ùîº.inv.g1 f n - 1),
  set f2 : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§ := Œª m n, f.1.1 (ùîº.inv.g1 f (m + n) - 1) - f.1.1 (ùîº.inv.g1 f m) - f.1.1 (ùîº.inv.g1 f n),
  set f3 : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§ := Œª m n, f.1.1 (ùîº.inv.g1 f (m + n) - (ùîº.inv.g1 f m) - (ùîº.inv.g1 f n)),
  have h2 : ‚àÄ m n (hm : N ‚â§ m) (h0n : 0 ‚â§ n) (hgn : 0 < ùîº.inv.g1 f n), f1 m n > 0 ‚àß f2 m n < 0,
    intros m n hm h0n hgn,
    rcases h1 m n hm h0n hgn with ‚ü®‚ü®hm1, hm2‚ü©, ‚ü®hn1, hn2‚ü©, ‚ü®hmn1, hmn2‚ü©‚ü©,
    simp only [sub_lt_zero, gt_iff_lt, sub_pos],
    split,
      linarith,
    linarith,
  have := lemma36 f1 f2 f3 h2 (lemma41 f) (lemma42 f),
  set T := {t | ‚àÉ m n (hm : N ‚â§ m) (hn : 0 ‚â§ n) (hgn : 0 < ùîº.inv.g1 f n), (ùîº.inv.g1 f (m + n) - (ùîº.inv.g1 f m) - (ùîº.inv.g1 f n)) = t},
  have hCT : ‚àÉ C, ‚àÄ x ‚àà T, abs (f.1.1 x) < C,
    cases this with E hE,
    use E,
    intros x hxT,
    rcases hxT with ‚ü®m, n, hm, hn, hgn, h‚ü©,
    specialize hE m n hm hn hgn,
    rw ‚Üê h,
    linarith,
  cases lemma37 f T hCT with C1 hC1,
  have h3 : ‚àÄ m n (hm : N ‚â§ m) (h0n : 0 ‚â§ n) (hgn : 0 = ùîº.inv.g1 f n), (f.1.1 (ùîº.inv.g1 f m - 1) < m ‚àß m ‚â§ f.1.1 (ùîº.inv.g1 f m)) ‚àß 
    (n ‚â§ f.1.1 (ùîº.inv.g1 f n)) ‚àß (f.1.1 (ùîº.inv.g1 f (m + n) - 1) < m + n ‚àß m + n ‚â§ f.1.1 (ùîº.inv.g1 f (m + n))),
    intros m n hm h0n hgn,
    have h0m : 0 ‚â§ m,
      linarith,
    have h0mn : 0 ‚â§ m + n,
      linarith,
    have hmn : N ‚â§ m + n,
      linarith,
    use [lemma43 f m h0m (hfN m hm), lemma35 f n h0n, lemma43 f (m + n) h0mn (hfN (m + n) hmn)],
  set f1' : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§ := Œª m n, f.1.1 (ùîº.inv.g1 f (m + n)) - f.1.1 (ùîº.inv.g1 f m - 1),
  set f2' : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§ := Œª m n, f.1.1 (ùîº.inv.g1 f (m + n) - 1) - f.1.1 (ùîº.inv.g1 f m) - f.1.1 (ùîº.inv.g1 f n),
  set f3' : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§ := Œª m n, f.1.1 (ùîº.inv.g1 f (m + n) - (ùîº.inv.g1 f m) - (ùîº.inv.g1 f n)),
  have h4 : ‚àÄ m n (hm : N ‚â§ m) (h0n : 0 ‚â§ n) (hgn : 0 = ùîº.inv.g1 f n), f1' m n > 0 ‚àß f2' m n < 0,
    intros m n hm h0n hgn,
    rcases h3 m n hm h0n hgn with ‚ü®‚ü®hm1, hm2‚ü©, hn1, ‚ü®hmn1, hmn2‚ü©‚ü©,
    simp only [sub_lt_zero, gt_iff_lt, sub_pos],
    split,
      linarith,
    linarith,
  have := lemma45 f1' f2' f3' h4 (lemma44 f) (lemma42 f),
  set T' := {t | ‚àÉ m n (hm : N ‚â§ m) (hn : 0 ‚â§ n) (hgn : 0 = ùîº.inv.g1 f n), (ùîº.inv.g1 f (m + n) - (ùîº.inv.g1 f m) - (ùîº.inv.g1 f n)) = t},
  have hCT' : ‚àÉ C, ‚àÄ x ‚àà T', abs (f.1.1 x) < C,
    cases this with E hE,
    use E,
    intros x hxT,
    rcases hxT with ‚ü®m, n, hm, hn, hgn, h‚ü©,
    specialize hE m n hm hn hgn,
    rw ‚Üê h,
    linarith,
  cases lemma37 f T hCT with C1 hC1,
  cases lemma37 f T' hCT' with C2 hC2,
  use [N, (max C1 C2) + 1],
  intros m n hm hn,
  by_cases hgn : 0 = ùîº.inv.g1 f n,
  { specialize hC2 (df (Œª (p : ‚Ñ§), ùîº.inv.g1 f p) m n),
    have : df (Œª (p : ‚Ñ§), ùîº.inv.g1 f p) m n ‚àà T',
      simp,
      use [m, hm, n, hn, hgn],
    specialize hC2 this,
    linarith [le_max_right C1 C2], },
  { have hgn' : 0 < ùîº.inv.g1 f n,
      have := lemma31 f n hn,
      exact lt_of_le_of_ne this hgn,
    specialize hC1 (df (Œª (p : ‚Ñ§), ùîº.inv.g1 f p) m n),
    have : df (Œª (p : ‚Ñ§), ùîº.inv.g1 f p) m n ‚àà T,
      simp,
      use [m, hm, n, hn, hgn'],
    specialize hC1 this,
    linarith [le_max_left C1 C2], },
end

lemma lemma47 (f : P') : ‚àÉ (C : ‚Ñ§) , ‚àÄ (m n : ‚Ñ§), 0 ‚â§ m ‚Üí 0 ‚â§ n ‚Üí abs (df (Œª (p : ‚Ñ§), ùîº.inv.g1 f p) m n) < C :=
begin
  rcases lemma46 f with ‚ü®N, C, hfN‚ü©,
  have hfs1 : set.finite (set.image2 (Œª m n, abs (df (Œª (p : ‚Ñ§), ùîº.inv.g1 f p) m n)) {m | 0 ‚â§ m ‚àß m < N} {n | 0 ‚â§ n ‚àß n < N}),
    apply set.finite.image2,
      split,
      apply fintype.of_finset (finset.Ico_‚Ñ§ 0 N),
      simp,
    split,
    apply fintype.of_finset (finset.Ico_‚Ñ§ 0 N),
    simp,
  have hbdd : bdd_above (set.image2 (Œª m n, abs (df (Œª (p : ‚Ñ§), ùîº.inv.g1 f p) m n)) {m | 0 ‚â§ m ‚àß m < N} {n | 0 ‚â§ n ‚àß n < N}),
    apply set.finite.bdd_above hfs1,
  unfold bdd_above at hbdd,
  unfold upper_bounds at hbdd,
  cases hbdd with C1 hC1,
  simp at hC1,
  use max C C1 + 1,
  intros m n hm hn,
  have hmN := lt_or_le m N,
  have hnN := lt_or_le n N,
  cases hmN,
  { cases hnN,
      specialize @hC1 (abs (ùîº.inv.g1 f (m + n) - ùîº.inv.g1 f m - ùîº.inv.g1 f n)) m hm hmN n hn hnN rfl,
      simp,
      linarith [le_max_right C C1],
    specialize hfN n m hnN hm,
    simp at hfN,
    simp,
    have : ùîº.inv.g1 f (m + n) - ùîº.inv.g1 f m - ùîº.inv.g1 f n = ùîº.inv.g1 f (n + m) - ùîº.inv.g1 f n - ùîº.inv.g1 f m,
      rw [add_comm],
      ring,
    rw this,
    linarith [le_max_left C C1], },
  { specialize hfN m n hmN hn,
    linarith [le_max_left C C1], },
end

noncomputable def ùîº.inv.g : P' ‚Üí S := Œª f, ‚ü®Œª p, ùîº.inv.g1 f p, 
begin
  apply lemma26,
  { intros p hp,
    unfold ùîº.inv.g1,
    split_ifs with hp1 hp2,
          exfalso,
          linarith,
        exfalso,
        linarith,
      refl,
    exfalso,
    linarith, },
  exact lemma47 f,
end‚ü©

lemma lemma48 (f : P') : ‚àÉ (C : ‚Ñ§), ‚àÄ n (hn : 0 ‚â§ n), abs (f.1.1 ((ùîº.inv.g f).1 n) - n) < C :=
begin
  have H : ‚àÉ (N C : ‚Ñ§), ‚àÄ n (hn : N ‚â§ n), abs (f.1.1 ((ùîº.inv.g f).1 n) - n) < C,
    rcases lemma34 f with ‚ü®N, hN, h‚ü©,
    have hN' : 0 ‚â§ N,
      linarith,
    set g := ùîº.inv.g f with hg,
    choose C hC using f.1.2,
    use [N, C + abs (f.1.1 1)],
    intros n hn,
    specialize h n hn,
    have h0n : 0 ‚â§ n,
      linarith,
    have key := lemma43 f n h0n h,
    have : g.val = ùîº.inv.g1 f,
      rw hg,
      refl,
    rw ‚Üê this at *,
    specialize hC 1 (g.1 n - 1),
    simp only [add_sub_cancel'_right, d_equal] at hC,
    cases key,
    rw abs_lt at *,
    cases hC,
    split,
      linarith [abs_nonneg (f.1.1 1)],
    linarith [le_abs_self (f.1.1 1)],
  rcases H with ‚ü®N, C, H‚ü©,
    have hfin : set.finite ((Œª n, abs (f.1.1 ((ùîº.inv.g f).1 n) - n)) '' set.Ico 0 N),
    apply set.finite.image,
    split,
    apply fintype.of_finset (finset.Ico_‚Ñ§ 0 N),
    simp,
  have hbdd : bdd_above ((Œª n, abs (f.1.1 ((ùîº.inv.g f).1 n) - n)) '' set.Ico 0 N),
    apply set.finite.bdd_above hfin,
  unfold bdd_above at hbdd,
  unfold upper_bounds at hbdd,
  cases hbdd with C1 hC1,
  simp only [and_imp, set.mem_Ico, set.mem_image, set.mem_set_of_eq, exists_imp_distrib] at hC1,
  use max C C1 + 1,
  intros n hn,
  have hnN := lt_or_le n N,
  cases hnN,
    specialize @hC1 (abs (f.val.val ((ùîº.inv.g f).val n) - n)) n hn hnN rfl,
    linarith [le_max_right C C1],
  specialize H n hnN,
  linarith [le_max_left C C1],
end

lemma lemma49 : ‚àÄ (a : ùîº) (ha : a ‚àà P), ‚àÉ b, a * b = 1 :=
begin
  rintro a ‚ü®f, hf, h‚ü©,
  have hfP' : f ‚àà P',  
    exact h,
  use ‚Üë(ùîº.inv.g ‚ü®f, hfP'‚ü©),
  rw ‚Üê hf,
  unfold has_mul.mul distrib.mul ring.mul comm_ring.mul has_one.one monoid.one ring.one comm_ring.one,
  rw [lemma17, quotient_add_group.eq],
  apply lemma4,
  cases lemma48 ‚ü®f, hfP'‚ü© with C hC,
  use C,
  intros p hp,
  specialize hC p hp,
  rw ‚Üê abs_neg at hC,
  simp at hC,
  rw [add_comm],
  exact hC,
end

lemma lemma50 : ‚àÄ a b, a ‚àà P ‚Üí b ‚àà P ‚Üí a * b ‚àà P :=
begin
  intros a b ha hb,
  rcases ha with ‚ü®u, hu, ha‚ü©,
  rcases hb with ‚ü®v, hv, hb‚ü©,
  rw [‚Üê hu, ‚Üê hv],
  unfold has_mul.mul distrib.mul ring.mul field.mul comm_ring.mul division_ring.mul,
  rw lemma17,
  use [‚ü®u.val ‚àò v.val, lemma14 u v‚ü©, rfl],
  rw lemma8 at *,
  intros C hC,
  cases ha C hC with M hM,
  have : 0 < max M 1,
    rw lt_max_iff,
    right,
    norm_num,
  cases hb (max M 1) this with N hN,
  use N,
  intros p hNp,
  specialize hN p hNp,
  have hvval : M < v.val p,
    rw max_lt_iff at hN,
    exact hN.1,
  specialize hM (v.val p) hvval,
  exact hM,
end

lemma lemma51 : (1 : ùîº) ‚àà P :=
begin
  use [(‚ü®(id : ‚Ñ§ ‚Üí ‚Ñ§), lemma16‚ü© : S), rfl],
  intros n hn,
  use n + 1,
  split,
    linarith,
  simp,
end

noncomputable def ùîº.inv : ùîº ‚Üí ùîº := Œª a,
if ha1 : a ‚àà P then begin
  choose b hb using lemma49 a ha1,
  exact b,
end 
else if ha2 : a = 0 then (0 : ùîº) else begin
  choose b hb using lemma49 (-a) (lemma30 ha1 ha2),
  exact -b,
end

noncomputable instance field_ùîº : field ùîº :=
{ inv := ùîº.inv,
  exists_pair_ne := begin
    use [0, 1],
    have h0P := lemma10,
    have h1P := lemma51,
    intro h01,
    rw h01 at h0P,
    exact h0P h1P,
  end,
  mul_inv_cancel := begin
    intros a ha,
    unfold has_inv.inv ùîº.inv,
    split_ifs,
      have := classical.some_spec (lemma49 a h),
      exact this,
    have := classical.some_spec (ùîº.inv._proof_2 a h ha),
    have heq : a * -(classical.some (ùîº.inv._proof_2 a h ha)) = 
      -a * (classical.some (ùîº.inv._proof_2 a h ha)),
      ring,
    rw heq,
    exact this,
  end,
  inv_zero := begin   
    unfold has_inv.inv ùîº.inv,
    split_ifs,
      exfalso,
      exact lemma10 h,
    refl,
  end,
  ..comm_ring_ùîº }

noncomputable instance linear_ordered_field_ùîº : linear_ordered_field ùîº :=
{ le := Œª a b, -a + b ‚àà P ‚à™ {0},
  lt := Œª a b, -a + b ‚àà P,
  le_refl := begin
    intro a,
    simp,
  end,
  le_trans := begin
    intros a b c hab hbc,
    simp at *,
    cases hab,
    { cases hbc,
      { left,
        rw [neg_add_eq_zero.mp hab, neg_add_eq_zero.mp hbc],
        simp, },
      { rw neg_add_eq_zero.mp hab,
        cc, }, },
    { cases hbc,
      { rw ‚Üê (neg_add_eq_zero.mp hbc),
        cc, },
      { right,
        have h : (-a + b) + (-b + c) ‚àà P := lemma9 (-a + b) (-b + c) hab hbc,
        have heq : -a + c = (-a + b) + (-b + c),
          abel,
        rw heq,
        exact h, }, },
  end,
  lt_iff_le_not_le := begin
    intros a b,
    split,
    { intro hab,
      simp at hab,
      simp,
      split,
        cc,
      intro hfalse,
      cases hfalse,
      { rw neg_add_eq_zero.mp hfalse at hab,
        simp at hab,
        exact lemma10 hab, },
      { have heq : -b + a = -(-a + b),
          abel,
        rw heq at hfalse,
        exact lemma11 hab hfalse, }, },
    { rintro ‚ü®hab, hba‚ü©,
      cases hab,
      { exact hab, },
      { simp at hab,
        simp at hba,
        have : ¬¨(-b + a = 0),
          finish,
        exfalso,
        apply this,
        rw neg_add_eq_zero at *,
        exact eq.symm hab, }, },
  end,
  le_antisymm := begin
    intros a b hab hba,
    cases hab,
    { cases hba,
      { exfalso,
        have :  -b + a = -(-a + b),
          abel,
        rw this at hba,
        exact lemma11 hab hba, },
      { simp at hba,
        exact eq.symm (neg_add_eq_zero.mp hba), }, },
    { simp at hab,
      exact neg_add_eq_zero.mp hab, },
  end,
  add_le_add_left := begin
    intros a b hab c,
    show -(c + a) + (c + b) ‚àà P ‚à™ {0},
    have : -(c + a) + (c + b) = -a + b,
      abel,
    rw this,
    exact hab,
  end,
  mul_pos := begin
    intros a b ha hb,
    unfold has_lt.lt preorder.lt partial_order.lt ordered_add_comm_group.lt at *,
    simp at *,
    exact lemma50 a b ha hb,
  end,
  le_total := begin
    intros a b,
    unfold has_le.le preorder.le partial_order.le ordered_add_comm_group.le at *,
    simp at *,
    cases lemma29 (-a + b),
      left,
      right,
      exact h,
    cases h,
      left,
      left,
      exact h,
    simp at h,
    right,
    right,
    exact h,
  end,
  zero_lt_one := begin
    unfold has_lt.lt preorder.lt partial_order.lt ordered_add_comm_group.lt,
    simp,
    unfold field.zero comm_ring.zero field.one comm_ring.one add_comm_group.zero add_group.zero,
    simp,
    exact lemma51,
  end,
  ..field_ùîº }

lemma lemma52 : ‚àÄ n, (Œª p, n * p) ‚àà S  := 
begin
  intro n,
  use 1,
  intros p q,
  simp,
  ring,
  simp,
end

lemma lemma53 : ‚àÄ n : ‚Ñï, (n : ùîº) = 
  @coe ‚Ü•S ùîº eudoxus_reals_group.has_lift_t ‚ü®Œª p, n * p, lemma52 n‚ü© :=
begin
  intro n,
  induction n,
    simp,
    refl,
  simp,
  rw n_ih,
  ring,
  unfold has_one.one monoid.one ring.one division_ring.one field.one comm_ring.one,
  have : @coe ‚Ü•S ùîº eudoxus_reals_group.has_lift_t ‚ü®has_mul.mul ‚Üën_n, lemma52 n_n‚ü© + @coe ‚Ü•S ùîº eudoxus_reals_group.has_lift_t ‚ü®id, lemma16‚ü© = 
    @coe ‚Ü•S ùîº eudoxus_reals_group.has_lift_t (‚ü®has_mul.mul ‚Üën_n, lemma52 n_n‚ü© + ‚ü®id, lemma16‚ü©),
    refl,
  rw this,
  unfold has_add.add add_semigroup.add add_monoid.add add_group.add,
  simp,
  have heq : ‚àÄ (z : ‚Ñ§), ‚Üën_n * z + z = (‚Üën_n + 1) * z,
    intro z,
    ring,
  simp_rw heq,
  refl,
end

lemma lemma54 (f g : S) (hfg : (‚Üëf : ùîº) = ‚Üëg) : (‚àÄ (C : ‚Ñ§), 0 < C ‚Üí (‚àÉ (N : ‚Ñ§), ‚àÄ (p : ‚Ñ§), N < p ‚Üí C < f.val p))
  ‚Üí (‚àÄ (C : ‚Ñ§), 0 < C ‚Üí (‚àÉ (N : ‚Ñ§), ‚àÄ (p : ‚Ñ§), N < p ‚Üí C < g.val p)) :=
begin
  intro hf,
  intros C hC,
  have hfg' : (0 : ùîº) = -‚Üë(f : S) + ‚Üë(g : S),
    rw hfg,
    simp,
  change ‚Üë(0 : S) = ‚Üë(-f + g) at hfg',
  rw quotient_add_group.eq at hfg',
  simp at hfg',
  cases hfg' with B hB,
  change ‚àÄ (p : ‚Ñ§), abs (-f.val p + g.val p) < B at hB,
  have h0BC : 0 < B + C,
    linarith [hB 0, abs_nonneg (-f.val 0 + g.val 0)],
  cases hf (B + C) h0BC with N hN,
  use N,
  intros p hNp,
  specialize hN p hNp,
  specialize hB p,
  rw abs_lt at hB,
  cases hB,
  linarith,
end

lemma lemma55 {f g : S} (B : ‚Ñ§) : (0 : ùîº) < ‚Üëg ‚Üí (‚àÄ p, abs (f.1 p) < abs (g.1 p) + B) ‚Üí (‚Üëf : ùîº) ‚â§ ‚Üëg :=
begin
  rintro ‚ü®v, hvg, hv‚ü© habs,
  simp at hvg,
  by_contradiction hfalse,
  simp at hfalse,
  change ‚Üë((-g) + f) ‚àà P at hfalse,
  rcases hfalse with ‚ü®gf, hgf, hfalse‚ü©,
  rw lemma8 at *,
  have h1 := lemma54 gf (-g + f) hgf hfalse,
  have h2 := lemma54 v g hvg hv,
  have : (0 : ‚Ñ§) < max B 1,
    rw lt_max_iff,
    norm_num,
  cases h1 (max B 1) this with N1 h1,
  cases h2 (max B 1) this with N2 h2,
  have hle1 : N1 < max N1 N2 + 1,
    linarith [le_max_left N1 N2],
  have hle2 : N2 < max N1 N2 + 1,
    linarith [le_max_right N1 N2],
  specialize h1 (max N1 N2 + 1) hle1,
  specialize h2 (max N1 N2 + 1) hle2,
  specialize habs (max N1 N2 + 1),
  change max B 1 < -g.val (max N1 N2 + 1) + f.val (max N1 N2 + 1) at h1,
  have heq : abs (g.val (max N1 N2 + 1)) = g.val (max N1 N2 + 1),
    rw abs_of_pos,
    linarith,
  rw [heq, abs_lt] at habs,
  cases habs,
  linarith [le_max_left B 1],
end

lemma lemma56 : ‚àÄ a : ùîº, ‚àÉ (n : ‚Ñï) (hn : 0 < n), a ‚â§ (n : ùîº) :=
begin
  intro a,
  cases lemma12 a with u hu,
  rcases lemma23 u with ‚ü®A, B, hA, hAB‚ü©,
  have := int.eq_coe_of_zero_le (le_of_lt hA),
  cases this with n hAn,
  have hn : 0 < n,
    rw hAn at hA,
    exact int.coe_nat_pos.mp hA,
  use [n, hn],
  rw [‚Üê hu, lemma53],
  apply lemma55 B,
    rw ‚Üê lemma53,
    exact nat.cast_pos.mpr hn,
  rw ‚Üê hAn,
  intro p,
  specialize hAB p,
  have :  A * abs p = abs (A * p),
    have heq : abs A * abs p = abs (A * p) := (abs_mul A p).symm,
    rw abs_of_pos hA at heq,
    exact heq,
  rw this at hAB,
  exact hAB,
end

instance archimedean_ùîº : archimedean ùîº :=
{ arch := begin
    intros x y hy,
    rcases lemma56 x with ‚ü®D, h0D, hD‚ü©,
    rcases lemma56 y‚Åª¬π with ‚ü®E, h0E, hE‚ü©,
    have h0DE : 0 ‚â§ D * E := zero_le (D * E),
    use D * E,
    simp,
    have h0y : 0 < y‚Åª¬π,
      exact inv_pos.mpr hy,  
    rw [‚Üê mul_le_mul_right h0y, mul_assoc, mul_inv_cancel],
    { simp,
      apply mul_le_mul hD hE,
        linarith, 
      exact nat.cast_nonneg D, }, 
    linarith,
  end }
